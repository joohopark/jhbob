#  N-Queens Problem

## 조건

- 가로 세로 n개의 체스판 - chess[n][n]
- n개의 여왕말을 놓을 수 있는가?
	- 여왕말은 북,북동,동,동남,남,남서,서,북서 총 8방향이 동 가능하며, 각 여왕말들이 이 방위에 겹쳐서는 안된다.

## 문제

- 2차원 [n][n] 배열의 체스 판에서 n개의 여왕말을 서로 죽이지 않고 놓으려 할때 발생 가능한 경우의 수를 구하라.

## 풀이

- 상태 공간 트리를 통해 모든 경우의 수를 노드를 통해 표현 할 수 있음.
- 상위 노드에서 이미 놓을 수 없는 경우라고 판단된 뒤에도 하위 노드들을 계속 탐색하는 것은 비효율.
	- 오답인 경우를 마주 하였을때 직전 탐색 부모 노드로 돌아가 탐색을 진행 하는것을 BackTracking 기법이라고 하며, nqueens 문제에서는 이 방법을 통해 푸는것이 효율 적임.
    - BackTracking을 판단하기 위해서는 다음 말이 놓일 경우 이 수로 인하여 하위 노드 탐색 하는것에 있어 유망한지를 판단 해야 함.
    - nqueens 문제에서는 하위 노드가 되기 위해서는 아래의 조건을 만족 해야 한다.
    
    1. 부모 level에 놓인 여왕과 같은 level에 위치하지 말것,
      - 여왕이 놓인 위치를 하나의 배열을 통해 표현 하게 된다면 1번 문제는 해결된다.
      - 어차피 문제를 푸는것에 있어 해당 level에 어느 열에 위치 할지를 알고, 부모 노드가 어떤 열에 위치 하게 되는지를 파악하는것이 가능하다면 상관이 없기 때문에 1차원 배열을 통해 문제를 해결한다.
      - list[i] = j 라면, i행 j열에 위치 한다. 라고 인식해도 상관이 없음.
    2. 부모 level에 놓인 여왕과 같은 Colum에 위치하지 말것.
      - 현재 놓일 level이 i 이고, 1번의 표기 방법을 사용한다면 현재 놓일 하위 노드의 말의 열 위치가 0~i-1 번 인덱스의 값들과 동일하게 되는지를 검색하여 같은 열인지 확인이 가능하다.
    3. 부모 level에 놓인 여왕과 대각선으로 마주 하지 말것.
    	- 대각선은 가로, 세로의 길이가 동일 한 경우이다. 부모 행 - 자식 행 == |list[부모]- list[자식]|을 통해 판단이 가능하다.
    
<pre>
//level 행에 도착해서 유망한 노드를 탐색하는 함수.

queens(level){// 파라미터: 현재 탐색 중인 노드의 위치
    
    if 현재 해당 노드에 위치하는것이 유망하지 않다?{
        return false
    }else if 현재 도착 노드가 답인 경우{
        return true
    }else{// 답이 아니면서 유망한 경우.
        자식 노드 탐색 // 이곳에서 재귀 진행.
    }
    
    }
</pre>
    

- cols와 level을 통해 노드의 탐색 위치를 표현
- level은 행으로 0~ N-1까지 표현
- 입력 값으로 level이 들어온다면 0...level-1 행까지 모든 말이 위치를 얻었음을 의미.
- cols[i] = j 라면, i행 j열에 위치










note
<pre>
State Space Tree
트리의 hierarchy가 밑으로 내려갈수록 상위 노드에서부터 하위 노드까지의 모든 경우의 수를 표현 하는 트리.
실질적으로 구현하는것은 아니고 하나의 개념정도로 알고 넘어갈것.
구현은 2차원 배열로진행 해도 크게 상관이 없다.
0,0~n-1 의 좌표가 상단 노드
n-1,0~n-1 의 좌표가 최 하단 노드라고 생각하고 진행하면 된다.

BackTracking 
트리(상태 공간 트리)를 구성하는 각 노드들의 유망성(해를 찾을 수 있는지에 대한)을 판단 한 후 그렇지 않으면(non-promising) 그 노드의 자식노드는 탐색에서 제외.
- Recursion VS Stack 



DFS, Depth First Search
트리를 탐색함에 있어 더이상 나아갈 노드가 존재 하지 않을때까지 탐색 진행. 이후에는 이전 위치로 돌아와 다시 탐색 진행.
방향은 트리의 좌측 부터 진행한다.

</pre>

<pre>
if 이 노드가 유망한가? 계속 탐색 : 리턴( 유망하지 않음을 체크하고..)
if 현재 방문한 노드가 찾고있던 경우의 수인가? 답 출력 : 리턴
그것도 아니라면 자식 노드를 계속 탐색.

- 매개변수는 탐색 할 노드, 트리의 각 행, 각 행들의 열 을 통해 현재 노드들의 위치를 전달 할 수 있다.

- 행 (level 또는 stage로 표현)이 증가 했다라는 것은, level - 1개의 말이 현재 정렬이 되었다 라는 뜻과 동일.


var cols:[Int] = []//현재 탐색에 성공한 말들의 위치의 열들이 각 인덱스마다 추가됨. 인덱스 == level
**func queens() -> Bool{

if !promissing(level){
	return false
}else if level == N{//N은 목표 level
	return true
}

for i in 1...N{
	cols[level+1] = i
	if (queens(level+1)){
		return true
	}
}

return false// 현재 시도중에는 말을 놓을 수 있는 열이 존재 하지 않다.
}

유망성 Test

func promissing(level : Int){
	
	for i in 1...level{
		if cols[i] == cols[level]{// 상위 level( 현제 0~level-1 까지)과 같은 열에 위치 하게 되는지 검사
			return false
		}else if level - i == |cols[level]-cols[i]|{// 대각선인지 구하는 공식.
		
		}//같은 대각선에 있는지 검사
	}
	return true
}
**</pre>


###Reference

- [DFS](http://blog.eairship.kr/268)

