# Recursion fuction

> 자기 자신을 호출하는 함수 or 메소드

학부때 정말 굳이 알 필요 있을까 싶었던 개념이었는데.. 복잡한 코드를 줄이기엔 이만한 개념이 없는듯 싶어 정리.



```
func recursionSum(n: Int) -> Int{

// Base Case: 재귀에 빠지지 않는 경우, 종료 될 조건.
// 재귀는 적어도 하나의 Base Case를 갖고 있어야 한다.
	if n > 0{

// Recursion Case: 재귀 반복을 할때 Base Case로 접근 할 수 있도록 해야 함.
		return n + resursionSum(n: n-1)
	}
	
	return n
   
   // return n>0 ? n+recursionSum(n: n-1) : n
}
```

## Recursion의 구성.


> 재귀는 Base Case, Recursion Case를 갖고 있어야 함.

- 수학적 귀납법을 통하여 재귀 함수의 이론을 설명 할 수 있을 정도로 매우 일치 함. 
	- 수학적 귀납법 : 모든 자연수에 대해서 주어진 성질을 만족 한다는 명제를 증명.
	- Recursion : 구현해야되는 로직에 입력될 모든 조건에 대해 정상적으로 동작이 가능하다는것을 증명.( 이부분은 말이 잘 안되는것 같네.. 이해는되는데..)

위 함수를 귀납법으로 정리를 해보면

- n = 0 일때 0을 반환. (Base Case)
	- 0~0까지의 합은 0, 일치.
- n > 0 일때 n + func(n-1)
	- 위의 명제에 따라 n=0이 될때까지, 즉 BaseCase를 만족할때까지 n+ n-1+ n-2.....의 계산을 반복 수행. 
	- BaseCase를 만족하도록 로직이 수렴하도록 만드는것이 Recursion Case의 작성 방법!

n이 1이 될때까지 반복한 후 로직이 종료.

> **리턴이 되는 시점**!!!!에 n+ n-1+ n-2...+ 1까지의 계산이 진행된다고 생각하면 이해가 편함.

- 나는 리턴이 되는 시점에서 이해가 빡!! 됨. **리턴이 되는 시점에 식이 완성이 된다.** 


## 필수 조건.

- 재귀를 사용할 경우 무한 루프로 빠지지 않으려면 재귀 안에서 적당한 시점에 루프를 빠져나올 수 있도록 특정 조건을 주어줘야 한다.
	- 루프를 빠져나오는 조건을 만족하게 되면 return 하도록..
	- return 되면 마지막 전 함수 부터 순차적으로 함수가 종료 될 수 있도록 구현해야 한다.


- 세상에.. Factorial의 경우 간단한 식을 통해 구현을 생략 할 수 있겠다..

<pre>
0! = 1이고,
n! = n*(n-1)!//n-1은 Recursion Case 
BaseCase : n>0


func factorial(n: Int){

return n==0 ? 1 : n*factorial(n-1)

}
</pre>

- 대표적인 fibonacci의 수도 간단히 식을 통해 구현 가능!!

<pre>
f0 = 0
f1 = 1
fn = fn-1 + fn-2, if n>1


func recursionFibo(n: Int) -> Int{

	if n == 0{
		return 0
	}else if n == 1{
		return 1
	}
	
	return recursionFibo(n-1) + recursionFibo(n-2)

}

// 재귀 아닌 경우


func fibo(n: Int) -> Int{
    
    var result: Int = 0
    var tmp: Int = 1
    var current: Int = 0
    
    
    if n == 1{// 1번째는 값이 0
        return 0
    }else if n == 2{// 2번째는 값이 1
        return 1
    }else{
        for _ in 2...n{//3번째부터 tmp를 이전항으로 하고 다음 항을 엘리먼트 + tmp 로 진행, 계산 끝나면 tmp의 값이 변경, 첫 계산은 tmp는 2번째 항의 값을 갖는다.

            current = result// 결과 항은 현재 항이 된다.
            result = tmp + current// 이전항과 현재 항을 더한다.
            tmp = current//현재 항은 이전항이 된다.
            
            
            print(tmp)
        }
    }
    
    
    
    return result
    
}

</pre>

> recursive 하게 구현한 함수와 recursive하지 않은 함수의 경우, 차이는 recursive하지 않을 경우 인스턴스의 생성이 많아진다는 점. 즉, 변수의 갯수가 많아진다. 

- 위의 fibonachi를 보면 알겠지만 **반복문으로 표현가능하다면, Recursive하게 표현이 가능하다.**

## Recursive VS 반복문.

|           | 장점                                                                                                                                                                               | 단점                                                                                                                                |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| 반복문    | - 지금의 나에게 익숙하다.  - Function Call이 없기때문에 Function Stack으로 인한 메모리 이득이 있을 수도..                                                                          | - 구현시, 복잡한 로직의 경우 코드의 길이가 매우 길어진다. - 변수가 많이 필요하다.                                                   |
| Recursive | - 익숙해지면 복잡한 문제를 표현하기에 매우 편리..하다고 한다. - 반복문을 표현할때보다 변수( 즉, 인스턴스)의 생성이 매우 불필요함. - Function Stack과 인스턴스 생성에대한 차이 정도 | - Function Stack으로 인한 메모리 오버 플로우를 감안해야한다. - 익숙해 지지 않으면 Recursive하게 구현 하는거 자체에 시간이 오래걸림. |

## Recursion, 재귀.. 꼭 필요한가..?

- 솔직히 재귀는 똑똑한 사람의 전유물이라 생각 할 정도로 별 감흥이 없었음.
- 재귀는 한번 익숙해 지면 복잡한 수식을 간단히 표현하기에 매우 적합한 스킬... 이라고함.. 오늘 정리만 봐도 그렇다..
- 간단히 표현된다 -> 가독성이 좋은 코드가 된다.. 라고 고려되기 때문에 재귀를 사랑해야한다.
- 오늘부터 1 프로젝트 1 재귀 진행해야됨.
